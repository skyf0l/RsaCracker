use std::str::FromStr;

use rsacracker::{integer_to_string, run_attacks, KeyEntry, Parameters};
use rug::Integer;

#[test]
fn square_ctf_2017_c1_gotta_decrypt_them_all() {
    // From Square CTF 2017 / C1: Gotta Decrypt Them All
    // https://ctftime.org/task/3973
    //
    // This is a Hastad's broadcast attack with e=3
    // The same message is encrypted to three different recipients with the same public exponent

    let e = Integer::from(3);

    let n1 = Integer::from_str("1001191535967882284769094654562963158339094991366537360172618359025855097846977704928598237040115495676223744383629803332394884046043603063054821999994629411352862317941517957323746992871914047324555019615398720677218748535278252779545622933662625193622517947605928420931496443792865516592262228294965047903627").unwrap();
    let c1 = Integer::from_str("261345950255088824199206969589297492768083568554363001807292202086148198540785875067889853750126065910869378059825972054500409296763768604135988881188967875126819737816598484392562403375391722914907856816865871091726511596620751615512183772327351299941365151995536802718357319233050365556244882929796558270337").unwrap();

    let n2 = Integer::from_str("405864605704280029572517043538873770190562953923346989456102827133294619540434679181357855400199671537151039095796094162418263148474324455458511633891792967156338297585653540910958574924436510557629146762715107527852413979916669819333765187674010542434580990241759130158992365304284892615408513239024879592309").unwrap();
    let c2 = Integer::from_str("147535246350781145803699087910221608128508531245679654307942476916759248311896958780799558399204686458919290159543753966699893006016413718139713809296129796521671806205375133127498854375392596658549807278970596547851946732056260825231169253750741639904613590541946015782167836188510987545893121474698400398826").unwrap();

    let n3 = Integer::from_str("1204664380009414697639782865058772653140636684336678901863196025928054706723976869222235722439176825580211657044153004521482757717615318907205106770256270292154250168657084197056536811063984234635803887040926920542363612936352393496049379544437329226857538524494283148837536712608224655107228808472106636903723").unwrap();
    let c3 = Integer::from_str("633230627388596886579908367739501184580838393691617645602928172655297372145912724695988151441728614868603479196153916968285656992175356066846340327304330216410957123875304589208458268694616526607064173015876523386638026821701609498528415875970074497028482884675279736968611005756588082906398954547838170886958").unwrap();

    let params = Parameters {
        n: Some(n1.clone()),
        e: e.clone(),
        c: Some(c1),
        keys: vec![
            KeyEntry {
                n: Some(n2),
                e: e.clone(),
                c: Some(c2),
            },
            KeyEntry {
                n: Some(n3),
                e,
                c: Some(c3),
            },
        ],
        ..Default::default()
    };

    let solution = run_attacks(&params).unwrap();

    // The attack should succeed with common_factor or similar multi-key attack
    assert!(solution.pk.is_some() || solution.m.is_some());

    if let Some(m) = solution.m {
        let plaintext = integer_to_string(&m).unwrap();
        assert!(plaintext.contains("flag") || !plaintext.is_empty());
    }
}
